<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阳曦</title>
  
  <subtitle>爱这夕阳，因为它等待着晨曦</subtitle>
  <link href="https://yocy.top/atom.xml" rel="self"/>
  
  <link href="https://yocy.top/"/>
  <updated>2023-10-27T10:29:16.000Z</updated>
  <id>https://yocy.top/</id>
  
  <author>
    <name>YounGCY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL8.0的窗口函数</title>
    <link href="https://yocy.top/post/abab406.html"/>
    <id>https://yocy.top/post/abab406.html</id>
    <published>2023-10-27T10:29:16.000Z</published>
    <updated>2023-10-27T10:29:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1>MySQL中的窗口函数</h1><h2 id="前言">前言</h2><p>最近在练习 sql 时碰到了一类题：查询表中的前 n 项。直接想到的是用 <code>order</code> 排序然后使用 <code>limit</code> 获取前 n 项。例如，获取每天刷题通过数最多的前三名用户id和刷题数，DDL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> questions_pass_record;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `questions_pass_record` (</span><br><span class="line">`question_type` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`device` <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`pass_count` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`<span class="type">date</span>` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> questions_pass_record <span class="keyword">VALUES</span>(<span class="number">101</span>, <span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;app&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;2020-03-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> questions_pass_record <span class="keyword">VALUES</span>(<span class="number">102</span>, <span class="string">&#x27;sql&#x27;</span>, <span class="string">&#x27;pc&#x27;</span>, <span class="number">15</span>,<span class="string">&#x27;2020-03-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> questions_pass_record <span class="keyword">VALUES</span>(<span class="number">102</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;pc&#x27;</span>, <span class="number">9</span>, <span class="string">&#x27;2021-04-09&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> questions_pass_record <span class="keyword">VALUES</span>(<span class="number">202</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;pc&#x27;</span>, <span class="number">11</span>, <span class="string">&#x27;2021-04-09&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> questions_pass_record <span class="keyword">VALUES</span>(<span class="number">104</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;app&#x27;</span>, <span class="number">3</span>,<span class="string">&#x27;2021-04-09&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> questions_pass_record <span class="keyword">VALUES</span>(<span class="number">105</span>, <span class="string">&#x27;sql&#x27;</span>, <span class="string">&#x27;pc&#x27;</span>, <span class="number">60</span>, <span class="string">&#x27;2018-08-15&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> questions_pass_record <span class="keyword">VALUES</span>(<span class="number">104</span>, <span class="string">&#x27;sql&#x27;</span>, <span class="string">&#x27;pc&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;2018-08-15&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> questions_pass_record <span class="keyword">VALUES</span>(<span class="number">304</span>, <span class="string">&#x27;sql&#x27;</span>, <span class="string">&#x27;pc&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;2018-08-15&#x27;</span>);</span><br></pre></td></tr></table></figure><p>编写查询 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `<span class="type">date</span>`, user_id, pass_count</span><br><span class="line"><span class="keyword">FROM</span> questions_pass_record</span><br><span class="line"><span class="keyword">WHERE</span> (`<span class="type">date</span>`, pass_count) <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> `<span class="type">date</span>`, <span class="built_in">MAX</span>(pass_count)</span><br><span class="line">    <span class="keyword">FROM</span> questions_pass_record</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> `<span class="type">date</span>`</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> `<span class="type">date</span>`, pass_count <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><table><thead><tr><th>date</th><th>user_id</th><th>pass_count</th></tr></thead><tbody><tr><td>2018-08-05</td><td>105</td><td>60</td></tr><tr><td>2020-03-01</td><td>102</td><td>15</td></tr><tr><td>2021-04-09</td><td>202</td><td>11</td></tr></tbody></table><p>显然，这不是我们想要的结果。那么该如何解决呢？在一些 DBMS（如 PostgreSQL、Oracle、Microsoft SQL Server、IBM Db2 等），已经考虑到了这种情况，提供了<strong>窗口函数</strong> 帮助我们查询。</p><h2 id="什么是窗口函数">什么是窗口函数</h2><p>MySQL 从 8.0 开始支持窗口函数，窗口函数一种用于在查询结果中执行聚合计算或排序操作的特殊函数。它们能够对查询结果集中的行进行分组、排序和排名，而无需使用 <code>GROUP BY</code> 子句。</p><p>这个功能在大多商业数据库中早已支持，也叫分析函数。</p><h2 id="语法详解">语法详解</h2><p>窗口函数的一般语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>窗口函数<span class="operator">&gt;</span>([参数]) <span class="keyword">OVER</span> ([<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>分组列<span class="operator">&gt;</span>]</span><br><span class="line">                        [<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>排序列<span class="operator">&gt;</span> <span class="operator">&lt;</span>排序方式<span class="operator">&gt;</span>]</span><br><span class="line">                        [窗口帧])</span><br></pre></td></tr></table></figure><h3 id="窗口函数（window-function-name）">窗口函数（window_function_name）</h3><p><code>window_function_name</code> 窗口函数可以是聚合函数和或非聚合函数，窗口函数可以和聚合函数一起使用，也可以单独使用。MySQL 8.0 支持以下几类窗口函数：</p><ol><li>序号函数：用于为窗口内的每一行生成一个序号，如 <code>ROW_NUMBER()</code>、<code>RANK()</code>、<code>DENSE_RANK()</code> 等；</li><li>分布函数：用于计算窗口内的每一行在整个分区中的相对位置，如 <code>PERCENT_RANK()</code>、<code>CUME_DIST()</code> 等；</li><li>前后函数：用于获取窗口内当前行的前后某一行的值，如 <code>LAG()</code>、<code>LEAD()</code> 等；</li><li>头尾函数：用于获取窗口内的第一行或最后一行的值，如 <code>PIRST_VALUE()</code>、<code>LAST_VALUE</code> 等；</li><li>聚合函数：用于计算窗口内的某个字段的聚合值，如 <code>SUM()</code>、<code>AVG()</code>、<code>MIN()</code>、<code>MAX()</code> 等；</li></ol><p>根据函数的定义，有些要设置参数，下面会再详细介绍。</p><h3 id="OVER">OVER</h3><p><code>OVER</code> 关键词用来标识是否使用窗口函数。<code>OVER</code> 关键字后面可以跟随 <code>(窗口规范)</code> 或窗口名称。</p><h3 id="PARTITION-BY">PARTITION BY</h3><p><code>PARTITION BY</code> 子句用来查询结果划分为不同的分区，窗口函数在每个分区上分别执行。</p><p>这种分组类似于普通的聚合函数中使用 <code>GROUP BY</code> 子句，但不同的是，窗口函数不会导致结果集的行数减少。相反，它会为每个输入行计算一个单独的结果，而不会对结果集进行聚合。</p><p>通过使用<code>PARTITION BY</code>，可以轻松在窗口函数中进行分组计算，并对每个分组应用相应的窗口函数逻辑。这提供了对数据的灵活控制和更精确的计算结果。</p><h3 id="ORDER-BY">ORDER BY</h3><p><code>ORDER BY</code> 子句用来对每个分区内查询结果进行排序，窗口函数将按照排序后的结果再进行计算。</p><h3 id="窗口帧">窗口帧</h3><p>窗口帧（Window Frame）是窗口函数中的一个概念，用于定义在每个分区中要处理的行的范围。它指定了相对于当前行的起始行和结束行的位置。</p><p>在窗口函数中，可以使用窗口帧来控制窗口函数计算的行的子集。窗口帧通过指定边界来定义要包含在窗口中的行。</p><p>有几种类型的窗口帧：</p><ol><li>行范围帧（ROW）：<code>ROWS BETWEEN &lt;start&gt; AND &lt;end&gt;</code>。在窗口中指定一定数量的行，相对于当前行而言。可以使用 <code>ROWS</code> 关键字来指定。例如，<code>ROWS 3 PRECEDING</code> 表示包括当前行及前面的 3 行。</li><li>范围帧（RANGE）：<code>RANGE BETWEEN &lt;start&gt; AND &lt;end&gt;</code>。在窗口中指定基于值的范围，而不是具体的行数。使用范围帧时，窗口函数必须有一个排序规则，并且基于排序规则确定范围。例如，<code>RANGE BETWEEN 100 PRECEDING AND 100 FOLLOWING</code> 表示基于值范围的窗口，包括相对于当前行的前 100 行和后 100 行。</li><li>当前行帧（CURRENT ROW）：表示只包括当前行自身。</li><li>UNBOUNDED PRECEDING：到分区的第一行为止。</li><li>UNBOUNDED FOLLOWING：到分区的最后一行为止。</li></ol><p><img src="/imgs/posts/MySQL8.0%E4%B8%AD%E7%9A%84%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/image-20231026191006500.png" alt="image-20231026191006500"></p><p>如果没有指定窗口帧，默认为 <code>RANGE BETWEEN UNBOUNED PRECEDING AND CURRENT ROW</code>，即分区开始到当前行。</p><h2 id="常用窗口函数">常用窗口函数</h2><h3 id="ROW-NUMBER"><code>ROW_NUMBER()</code></h3><p>用于生成每行的唯一编号的函数。它通常在数据库查询中使用，特别是在需要基于行顺序进行一些计算或排名的场景中。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (  </span><br><span class="line">    [<span class="keyword">PARTITION</span> <span class="keyword">BY</span> partition_expression]  </span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_expression [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_id, pass_count, <span class="type">date</span>, <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="type">date</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> pass_count <span class="keyword">DESC</span>) rk</span><br><span class="line"><span class="keyword">FROM</span> questions_pass_record;</span><br></pre></td></tr></table></figure><p>运行结果：</p><table><thead><tr><th>user_id</th><th>pass_count</th><th>date</th><th>rk</th></tr></thead><tbody><tr><td>105</td><td>60</td><td>2018-08-15</td><td>1</td></tr><tr><td>104</td><td>20</td><td>2018-08-15</td><td>2</td></tr><tr><td>304</td><td>10</td><td>2018-08-15</td><td>3</td></tr><tr><td>102</td><td>15</td><td>2020-03-01</td><td>1</td></tr><tr><td>101</td><td>2</td><td>2020-03-01</td><td>2</td></tr><tr><td>202</td><td>11</td><td>2021-04-09</td><td>1</td></tr><tr><td>102</td><td>9</td><td>2021-04-09</td><td>2</td></tr><tr><td>104</td><td>3</td><td>2021-04-09</td><td>3</td></tr></tbody></table><p>在上述示例中，我们使用 <code>ROW_NUMBER()</code> 函数来为每个提交记录按照日期分页，然后再根据 <code>pass_count</code> 降序排序，并为每条记录分配一个 <code>rk</code> 排名。</p><h3 id="RANK"><code>RANK()</code></h3><p><code>RANK()</code> 函数用于生成每行的排名。它考虑了并列名次的情况，并会跳过并列名次之后的名次。这意味着如果有多个行具有相同的排名，它们将获得相同的排名，并且下一个排名将会跳过。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> (  </span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_expression [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> questions_pass_record <span class="keyword">VALUES</span>(<span class="number">666</span>, <span class="string">&#x27;sql&#x27;</span>, <span class="string">&#x27;pc&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;2018-08-15&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> user_id, pass_count, <span class="type">date</span>, <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="type">date</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> pass_count <span class="keyword">DESC</span>) rk</span><br><span class="line"><span class="keyword">FROM</span> questions_pass_record;</span><br></pre></td></tr></table></figure><p>运行结果：</p><table><thead><tr><th>user_id</th><th>pass_count</th><th>date</th><th>rk</th></tr></thead><tbody><tr><td>105</td><td>60</td><td>2018-08-15</td><td>1</td></tr><tr><td>104</td><td>20</td><td>2018-08-15</td><td>2</td></tr><tr><td>666</td><td>20</td><td>2018-08-15</td><td>2</td></tr><tr><td>304</td><td>10</td><td>2018-08-15</td><td>4</td></tr><tr><td>102</td><td>15</td><td>2020-03-01</td><td>1</td></tr><tr><td>101</td><td>2</td><td>2020-03-01</td><td>2</td></tr><tr><td>202</td><td>11</td><td>2021-04-09</td><td>1</td></tr><tr><td>102</td><td>9</td><td>2021-04-09</td><td>2</td></tr><tr><td>104</td><td>3</td><td>2021-04-09</td><td>3</td></tr></tbody></table><p>在上述示例中，可以看到，<code>user_id=666</code> 与 <code>user_id=104</code> 的排名重合，因此它俩的排名是一样的，随后下一个又跳过了 3。</p><h3 id="DENSE-RANK"><code>DENSE_RANK()</code></h3><p><code>DENSE_RANK()</code> 函数用于生成每行的密集排名。与<code>RANK()</code> 函数不同，<code>DENSE_RANK()</code> 函数在并列名次的情况下不会跳过下一个排名。这意味着如果有多个行具有相同的排序值，它们将获得相同的排名，并且下一个排名不会被跳过。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (  </span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_expression [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_id, pass_count, <span class="type">date</span>, <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="type">date</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> pass_count <span class="keyword">DESC</span>) rk</span><br><span class="line"><span class="keyword">FROM</span> questions_pass_record;</span><br></pre></td></tr></table></figure><p>运行结果：</p><table><thead><tr><th>user_id</th><th>pass_count</th><th>date</th><th>rk</th></tr></thead><tbody><tr><td>105</td><td>60</td><td>2018-08-15</td><td>1</td></tr><tr><td>104</td><td>20</td><td>2018-08-15</td><td>2</td></tr><tr><td>666</td><td>20</td><td>2018-08-15</td><td>2</td></tr><tr><td>304</td><td>10</td><td>2018-08-15</td><td>3</td></tr><tr><td>102</td><td>15</td><td>2020-03-01</td><td>1</td></tr><tr><td>101</td><td>2</td><td>2020-03-01</td><td>2</td></tr><tr><td>202</td><td>11</td><td>2021-04-09</td><td>1</td></tr><tr><td>102</td><td>9</td><td>2021-04-09</td><td>2</td></tr><tr><td>104</td><td>3</td><td>2021-04-09</td><td>3</td></tr></tbody></table><p>在上述示例中，可以看到，在排名重合后，<code>user_id=304</code> 的排名为 3 而不是 4，排名序号没有跳过。</p><h3 id="SUM-、AGV-、COUNT-等聚合函数"><code>SUM()</code>、<code>AGV()</code>、<code>COUNT()</code> 等聚合函数</h3><p>它们的用法同一般的聚合函数一样，可以在指定的窗口中进行聚合计算。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">date</span>, <span class="built_in">SUM</span>(pass_count) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="type">date</span>) <span class="keyword">AS</span> total_pass_count  </span><br><span class="line"><span class="keyword">FROM</span> questions_pass_record;</span><br></pre></td></tr></table></figure><p>运行结果：</p><table><thead><tr><th>date</th><th>total_pass_count</th></tr></thead><tbody><tr><td>2018-08-15</td><td>110</td></tr><tr><td>2018-08-15</td><td>110</td></tr><tr><td>2018-08-15</td><td>110</td></tr><tr><td>2018-08-15</td><td>110</td></tr><tr><td>2020-03-01</td><td>17</td></tr><tr><td>2020-03-01</td><td>17</td></tr><tr><td>2021-04-09</td><td>23</td></tr><tr><td>2021-04-09</td><td>23</td></tr><tr><td>2021-04-09</td><td>23</td></tr></tbody></table><p>在上述示例中，查询了每天的提交通过总数，多条记录的重复说明了<strong>窗口函数是对每条记录获取到一个窗口(从分区第一行到当前行)再进行聚合计算</strong>，用 <code>DISTINCT</code> 关键字去重即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   </span><br><span class="line"> <span class="keyword">DISTINCT</span> <span class="type">date</span>,   </span><br><span class="line"><span class="built_in">SUM</span>(pass_count) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="type">date</span>) <span class="keyword">AS</span> total_pass_count  </span><br><span class="line"><span class="keyword">FROM</span>   </span><br><span class="line">questions_pass_record;</span><br></pre></td></tr></table></figure><h3 id="LAG-LEAD"><code>LAG()</code>/<code>LEAD()</code></h3><p>窗口函数 <code>LAG()</code> 和 <code>LEAD()</code> 是用于访问窗口中前一行或后一行的数据的函数。它们都需要指定一个参数，即偏移量，表示要获取的前一行或后一行的位置。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LAG</span>(expression [, <span class="keyword">offset</span> [, <span class="keyword">default</span>]])  </span><br><span class="line"><span class="built_in">LEAD</span>(expression [, <span class="keyword">offset</span> [, <span class="keyword">default</span>]])</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>expression</code>：要访问的列或表达式。</li><li><code>offset</code>：可选的偏移量，表示要获取的前一行或后一行的位置。默认为1，表示获取前一行或后一行的数据。</li><li><code>default</code>：可选的默认值，当没有更多行可用时返回的默认值。如果未指定默认值，并且没有更多行可用，则返回NULL。</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id,</span><br><span class="line"><span class="type">date</span>,</span><br><span class="line">pass_count,</span><br><span class="line"><span class="built_in">LAG</span>(pass_count) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">date</span>) <span class="keyword">AS</span> lag_value,</span><br><span class="line"><span class="built_in">LEAD</span>(pass_count) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">date</span>) <span class="keyword">AS</span> lead_value</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">questions_pass_record;</span><br></pre></td></tr></table></figure><p>运行结果：</p><table><thead><tr><th>user_id</th><th>date</th><th>pass_count</th><th>lag_value</th><th>lead_value</th></tr></thead><tbody><tr><td>105</td><td>2018-08-15</td><td>60</td><td></td><td>20</td></tr><tr><td>104</td><td>2018-08-15</td><td>20</td><td>60</td><td>10</td></tr><tr><td>304</td><td>2018-08-15</td><td>10</td><td>20</td><td>20</td></tr><tr><td>666</td><td>2018-08-15</td><td>20</td><td>10</td><td>2</td></tr><tr><td>101</td><td>2020-03-01</td><td>2</td><td>20</td><td>15</td></tr><tr><td>102</td><td>2020-03-01</td><td>15</td><td>2</td><td>9</td></tr><tr><td>102</td><td>2021-04-09</td><td>9</td><td>15</td><td>11</td></tr><tr><td>202</td><td>2021-04-09</td><td>11</td><td>9</td><td>3</td></tr><tr><td>104</td><td>2021-04-09</td><td>3</td><td>11</td><td></td></tr></tbody></table><p>在上面的示例中，<code>LAG(pass_count)</code> 将返回当前行的前一行的 <code>pass_count</code> 值，<code>LEAD(pass_count)</code> 将返回当前行的后一行的 <code>pass_count</code> 值。</p><h2 id="窗口名称">窗口名称</h2><p>MySQL 8.0 中可以给窗口命名，然后在 OVER 子句中通过窗口名来引用。这样做的好处是减少重复代码，类似于 Java 中重复代码抽象出单独的方法。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id,</span><br><span class="line"><span class="type">date</span>,</span><br><span class="line">pass_count,</span><br><span class="line"><span class="built_in">LAG</span>(pass_count) <span class="keyword">OVER</span> w <span class="keyword">AS</span> lag_value,</span><br><span class="line"><span class="built_in">LEAD</span>(pass_count) <span class="keyword">OVER</span> w <span class="keyword">AS</span> lead_value</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">questions_pass_record</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">date</span>);</span><br></pre></td></tr></table></figure><p>在上面的示例中，定义了名为 <code>w</code> 的窗口，然后在 OVER 子句中引用它。</p><p>另外，窗口之间可以互相引用，但是要避免循环引用。</p><h2 id="案例分析">案例分析</h2><p>引用上面的表，下面具体来解决一些问题。</p><h3 id="将提交记录按照提交数进行排名">将提交记录按照提交数进行排名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="type">date</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> pass_count <span class="keyword">DESC</span>) rk</span><br><span class="line"><span class="keyword">FROM</span> questions_pass_record;</span><br></pre></td></tr></table></figure><p><img src="/imgs/posts/MySQL8.0%E4%B8%AD%E7%9A%84%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/image-20231027085010668.png" alt="image-20231027085010668"></p><h3 id="对比-ROW-NUMBER-、RANK-、DENSE-RANK-的区别">对比 <code>ROW_NUMBER()</code>、<code>RANK()</code>、<code>DENSE_RANK()</code> 的区别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="operator">*</span>,</span><br><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> row_num,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> ranking,</span><br><span class="line"><span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> dense_ranking</span><br><span class="line"><span class="keyword">FROM</span> questions_pass_record</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="type">date</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> pass_count <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure><p><img src="/imgs/posts/MySQL8.0%E4%B8%AD%E7%9A%84%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/image-20231027085446594.png" alt="image-20231027085446594"></p><h3 id="聚合窗口函数使用">聚合窗口函数使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="operator">*</span>,</span><br><span class="line"><span class="built_in">AVG</span>(pass_count) <span class="keyword">OVER</span> w <span class="keyword">AS</span> current_avg,</span><br><span class="line"><span class="built_in">SUM</span>(pass_count) <span class="keyword">OVER</span> w <span class="keyword">AS</span> current_sum,</span><br><span class="line"><span class="built_in">MAX</span>(pass_count) <span class="keyword">OVER</span> w <span class="keyword">AS</span> current_max,</span><br><span class="line"><span class="built_in">MIN</span>(pass_count) <span class="keyword">OVER</span> w <span class="keyword">AS</span> current_min</span><br><span class="line"><span class="keyword">FROM</span> questions_pass_record</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">date</span>);</span><br></pre></td></tr></table></figure><p><img src="/imgs/posts/MySQL8.0%E4%B8%AD%E7%9A%84%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/image-20231027090112187.png" alt="image-20231027090112187"></p><h3 id="经典-TOP-N-问题">经典 TOP N 问题</h3><p>所有提交记录取前 3 名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.user_id, a.pass_count, a.date, a.ranking</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> user_id, pass_count, <span class="type">date</span>, <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> pass_count <span class="keyword">DESC</span>) <span class="keyword">as</span> ranking</span><br><span class="line"><span class="keyword">FROM</span> questions_pass_record</span><br><span class="line">) <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">WHERE</span> a.ranking <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.ranking;</span><br></pre></td></tr></table></figure><p><img src="/imgs/posts/MySQL8.0%E4%B8%AD%E7%9A%84%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/image-20231027091633797.png" alt="image-20231027091633797"></p><p>统计每天前 2 的用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">date</span>, user_id, pass_count</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> user_id, pass_count, <span class="type">date</span>, <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="type">date</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> pass_count <span class="keyword">DESC</span>) rk</span><br><span class="line"><span class="keyword">FROM</span> questions_pass_record</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">WHERE</span> rk <span class="operator">&lt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="/imgs/posts/MySQL8.0%E4%B8%AD%E7%9A%84%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/image-20231027092640532.png" alt="image-20231027092640532"></p><h3 id="聚合滑动计算">聚合滑动计算</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 取当前行的前两行的平均</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">AVG</span>(pass_count) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id <span class="keyword">ROWS</span> <span class="number">2</span> PRECEDING) <span class="keyword">AS</span> current_avg</span><br><span class="line"><span class="keyword">FROM</span> questions_pass_record;</span><br></pre></td></tr></table></figure><p><img src="/imgs/posts/MySQL8.0%E4%B8%AD%E7%9A%84%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/image-20231027095342804.png" alt="image-20231027095342804"></p><h2 id="窗口函数的优缺点">窗口函数的优缺点</h2><p>优点：</p><ol><li>灵活性高：窗口函数允许用过户在查询结果中自定义的排序，聚合和华东计算操作，使得用户能够更加灵活地处理和分析数据。</li><li>性能优化：窗口函数通常比使用常规的聚合函数和子查询更加高效，因为它们在 DBMS 中进行了优化，能够利用更高效的算法来执行计算。</li><li>可读性强：使用窗口函数可以使查询结果更加可读，因为进行和函数封装，并且使用别名来表示结果。</li></ol><p>缺点：</p><ol><li>语义不清晰：窗口函数的语法较为复杂，初学者可能比较难以理解。</li><li>限制条件：某些数据库可能对窗口函数的支持优先。例如 MySQL 8.0 才支持窗口函数，而 MySQL 5.7 不支持。</li><li>性能开销：虽然窗口可以在一般情况下可以提高查询性能，但在处理大量数据时，使用窗口函数可能还会导致额外的计算和内存开销。</li></ol><blockquote><p>窗口函数的性能取决于窗口类型、窗口大小、分区数量、排序代价等。因为窗口函数只需要一次扫描数据，所以对于大多数情况来说，其性能优于使用子查询或连接的方法。</p><p>当窗口函数同一些聚合函数使用时，性能就会下降。</p><p>可以采用如下优化方法：</p><ol><li>选择合适的窗口函数，避免使用复杂或重复的窗口函数。</li><li>使用窗口别名来定义和引用窗口。</li><li>尽量减少分区和排序的代价，使用缩影和物化视图来加速分区和排序。</li><li>尽量减小窗口的大小，使用合适的窗口帧来限制窗口范围。</li><li>尽量使用并行来加速处理窗口函数的计算，利用多核或分布式系统来提高效率。</li></ol></blockquote><h2 id="总结">总结</h2><p>窗口函数的应用十分广泛，可以帮助我们更加灵活的处理数据、分析数据。在具体的场景中，还需要考虑一些优化技巧，提高查询效率。</p><p><strong>参考</strong></p><p>【1】<a href="https://zhuanlan.zhihu.com/p/164698823">MySQL窗口函数 - 知乎 (zhihu.com)</a></p><p>【2】<a href="https://juejin.cn/post/7031157682434211853">《MySQL 入门教程》第 22 篇 窗口函数 - 掘金 (juejin.cn)</a></p><p>【3】<a href="https://juejin.cn/post/7244487194173751351?from=search-suggest">MySQL8新特性窗口函数详解 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;MySQL中的窗口函数&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在练习 sql 时碰到了一类题：查询表中的前 n 项。直接想到的是用 &lt;code&gt;order&lt;/code&gt; 排序然后使用 &lt;code&gt;limit&lt;/code&gt; 获取前 n 项。例如，获取每</summary>
      
    
    
    
    <category term="notes" scheme="https://yocy.top/categories/notes/"/>
    
    
    <category term="笔记" scheme="https://yocy.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库" scheme="https://yocy.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://yocy.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java8-Stream流讲解</title>
    <link href="https://yocy.top/post/d3d942f0.html"/>
    <id>https://yocy.top/post/d3d942f0.html</id>
    <published>2023-09-30T15:57:19.000Z</published>
    <updated>2023-10-01T18:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是 Stream</h1><h2 id="Stream-简介">Stream 简介</h2><p>在处理集合数据时，常常需要对其进行各种操作，例如过滤、映射、规约等。而 Java 8 中引入的 Stream 流为我们提供一种更加简洁和灵活的方式来处理数据。</p><h2 id="Stream-特性">Stream 特性</h2><ol><li>stream 不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。</li><li>stream 不会改变数据源，通常情况下会产生一个新的集合或一个值。</li><li>stream 具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li></ol><h1>如何使用 Stream</h1><p>简单来讲，Stream 流操作分为以下 3 种：</p><ol><li>创建 Stream 流</li><li>Stream 流中间处理</li><li>终止 Stream 流</li></ol><h2 id="创建-Stream-流">创建 Stream 流</h2><h3 id="从-Collection-创建流">从 Collection 创建流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionToStreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; animals = Arrays.asList(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;fish&quot;</span>, <span class="string">&quot;bird&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = animals.stream();</span><br><span class="line">        </span><br><span class="line">        stream.filter(animal -&gt; animal.length() &lt;= <span class="number">3</span>)</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，首先创建了一个包含字符串元素的 List 集合，并使用 <code>Arrays.asList</code> 方法将元素添加到集合中。这里集合包含了&quot;cat&quot;, “dog”, “tiger”, “fish&quot;和&quot;bird”。</p><p>接下来调用 <code>animals.stream</code> 方法将 List 转化为一个流对象。这里使用了流的中间操作方法 <code>filter</code> 来过滤出长度小于等于 3 的元素。<code>filter</code> 方法接收一个 Lambda 表达式，对每个流元素进行判断，将符合条件的元素留下。</p><p>然后调用 <code>map</code> 方法将流中的元素转化为大写字母形式。这里使用了方法引用 <code>String::toUpperCase</code> 来指定转化的逻辑。</p><p>最后，代码调用 <code>forEach</code> 方法来遍历流中的元素并打印出来。这里使用了方法引用 <code>System.out::println</code> 来指定打印的逻辑。</p><h3 id="从数组中创建流">从数组中创建流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayToStreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line">        </span><br><span class="line">        stream.filter(num -&gt; num &gt; <span class="number">3</span>)</span><br><span class="line">                .map(num -&gt; num * <span class="number">10</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，首先创建了一个数组，再使用 <code>Arrays.stream</code> 将数组转为一个流对象。接着使用 <code>filter</code> 方法过滤掉小于等于 3 的元素，再用 <code>map</code> 方法将元素变成原来的 10 倍。最后调用 <code>forEach</code> 遍历执行输出。</p><h3 id="调用-Stream-的静态方法">调用 Stream 的静态方法</h3><h4 id="Stream-of-指定具体元素的流">Stream.of -  指定具体元素的流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;fish&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="Stream-iterate-迭代生成元素的流">Stream.iterate - 迭代生成元素的流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, (x) -&gt; x * <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="Stream-generate-指定-Supplier-生成元素的流">Stream.generate - 指定 Supplier 生成元素的流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Double&gt; stream = Stream.generate(Math::random)</span><br></pre></td></tr></table></figure><h3 id="Stream-Builder-创建流">* Stream.Builder 创建流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamBuilderExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.Builder&lt;String&gt; builder = Stream.builder();</span><br><span class="line">        </span><br><span class="line">        builder.add(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">                .add(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">                .add(<span class="string">&quot;tiger&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = builder.build();</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stream.Bulider</code> 帮助我们逐步构建一个流，通过 <code>add</code> 方法添加元素，然后使用 <code>build</code> 方法创建流。</p><h4 id="应用场景">应用场景</h4><p>因为其允许在构建流的过程中<strong>动态地</strong>创建流，所以这种构建方式适合元素不确定或者需要动态处理地场景。</p><h3 id="从文件创建流">*从文件创建流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileToStreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;./data.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(fileName))) &#123;</span><br><span class="line">            lines.filter(line -&gt; line.contains(<span class="string">&quot;abc&quot;</span>))</span><br><span class="line">                .forEach(System.out::println)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般处理文件的方式使用 <code>BufferedReader</code> 等类逐行读取，但是使用 Stream 流可以很方便的读取文件。例如上述代码中使用 <code>Files.lines</code> 方法，将文件的每一行转换成流，然后再对其进行一系列操作。</p><p>使用 Stream 流可以有效的使代码更加简洁，可读性强。此外 Stream 还提供了并行处理的能力，通过多线程进行并行计算，提高程序运行效率。使用 Stream 可以更加有效的管理内存，降低内存占用，提高效率。最后，Stream 的操作都是基于函数式编程的思想，通过方法引用或是 Lambda 表达式进行各种操作，可维护性和可扩展性好。</p><blockquote><p>关于 Stream 可以更加有效地管理内存资源的原因如下：</p><ul><li>惰性计算：Stream 是基于惰性计算的，只有当需要结果的时候才会执行。这意味着在处理大量数据时，可以按需计算，而不是一次性加载完所有的数据到内存中。这有效的节省了内存资源。</li><li>内部迭代：Stream 提供了一种内部迭代的方式，同时 Stream 内部已经优化了迭代的方式，可以更高效地利用内存资源。</li><li>并行处理：Stream 因为支持并行处理，将数据划分多个子任务并行处理，然后合并，充分利用了多核 CPU 的性能。同时 Stream 优化了任务的分配和调度，以最大限度地利用内存资源。</li></ul></blockquote><h2 id="Stream-流中间处理"><strong>Stream 流中间处理</strong></h2><p>在介绍具体的处理方法前，需要再明确 Stream 的一个特性——<strong>延迟性</strong>。当多个中间操作按顺序进行时，除非流终止，否则中间操作不会执行。</p><p>这样做的原因是提高性能，减少了对每个元素的实际操作数。</p><p>例如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;c1&quot;</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .anyMatch(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;anyMatch: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startWith(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map: a1</span><br><span class="line">anyMatch: A1</span><br><span class="line">map: a2</span><br><span class="line">anyMatch: A2</span><br><span class="line">map: b1</span><br><span class="line">anyMatch: B1</span><br></pre></td></tr></table></figure><p>由于数据流的链式调用是垂直执行的，<code>map</code> 在这里只执行 3 次。相当于水平执行来说，执行次数减少了，不是把所有的元素都进行 <code>map</code> 转换，从而提高了性能。</p><p>**所以，中间操作的顺序要考虑仔细！**例如，先 <code>map</code> 再 <code>filter</code> 和先 <code>filter</code> 再 <code>map</code> 的操作次数可能相差很大！</p><p>也有一些流处理方法是水平执行的，例如 <code>sorted</code>。当然，上面说到的优化技巧也同样适用于水平执行的流处理方法（先 <code>filter</code> 后再 <code>sorted</code>）。</p><h3 id="筛选与切片">筛选与切片</h3><table><thead><tr><th>API</th><th>功能说明</th></tr></thead><tbody><tr><td>filter(Predicate p)</td><td>接收 Lambda，从流中过滤不满足条件的元素</td></tr><tr><td>distinct()</td><td>去重筛选</td></tr><tr><td>limit(long maxSize)</td><td>截断流，使其元素不超过给定数量</td></tr><tr><td>skip(long n)</td><td>跳过元素，返回一个跳过前 n 个元素的流。若流中的元素不足 n 个，则返回一个空流。即与 limit(n) 互补</td></tr></tbody></table><h3 id="映射">映射</h3><table><thead><tr><th>API</th><th>功能说明</th></tr></thead><tbody><tr><td>map(Function f)</td><td>接收一个函数作为参数，该函数会被作用在每个元素上，一对一逻辑，返回新的 Stream</td></tr><tr><td>mapToDOuble(ToDoubleFunction f)</td><td>接收一个函数作为参数，该函数会被作用在每个元素上，产生一个新的 DoubleStream</td></tr><tr><td>mapToInt(ToIntFunction f)</td><td>接收一个函数作为参数，该函数会被作用在每个元素上，产生一个新的 IntStream</td></tr><tr><td>mapToLong(ToLongFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream</td></tr><tr><td>flatMap(Function f)</td><td>接收一个函数作为参数，将流中的每个值转换成一个流，一对多逻辑，然后连接它们成一个新的 Stream</td></tr></tbody></table><h4 id="map-与-flatMap-方法">map 与 flatMap 方法</h4><p><code>map</code> 与 <code>flatMap</code> 都是用于转换元素，区别在于：</p><ul><li><code>map</code> 必须是一对一的</li><li><code>flatMap</code> 可以是一对多的</li></ul><p><img src="/imgs/posts/Java8-Stream%E6%B5%81%E8%AF%A6%E8%A7%A3/image-20230930164708089.png" alt="image-20230930164708089"></p><p><code>map</code> 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><p>其参数是接收一个 Function，接收一个 T 型参数，返回一个 R 型参数，例如在实际业务中，将 DAO 类型转为对应的 DTO 类型。另外，当 T 和 R 相同时，也就和 <code>peek</code> 没什么区别了。</p><p><code>flatMap</code> 适用于<strong>将结构降维，即扁平化</strong>。一般有以下 3 种情况：</p><ol><li><code>Stream&lt;String[]&gt;</code></li><li><code>Stream&lt;Set&lt;String&gt;&gt;</code></li><li><code>Stream&lt;List&lt;String&gt;&gt;</code></li></ol><p>上述结构可通过 <code>flatMap</code> 方法，将结果转为 <code>Stream&lt;String&gt;</code>，方便后续操作。</p><p>另外，<code>flatMap</code> 可以和 <code>Optional</code> 类结合使用，减少繁琐的 null 检查。</p><p>假设有一个 <code>List&lt;Optional&lt;String&gt;&gt;</code>，我们想要将其中不为空的 <code>Optional</code> 对象中的字符串转换为大写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Optional&lt;String&gt;&gt; list = Arrays.asList(Optional.of(<span class="string">&quot;hello&quot;</span>), Optional.empty(), Optional.of(<span class="string">&quot;world&quot;</span>));</span><br><span class="line">List&lt;String&gt; result = list.stream()</span><br><span class="line">                          .flatMap(o -&gt; o.map(Stream::of).orElseGet(Stream::empty))</span><br><span class="line">                          .map(String::toUpperCase)</span><br><span class="line">                          .collect(Collectors.toList());</span><br><span class="line">System.out.println(result); <span class="comment">// 输出 [HELLO, WORLD]</span></span><br></pre></td></tr></table></figure><p>如果我们使用<code>map</code>方法对<code>Optional</code>对象进行映射，那么就需要进行繁琐的 null 检查，代码会变得更加复杂。</p><blockquote><p>当我们使用<code>map</code>方法对一个<code>Optional</code>对象进行映射时，如果<code>Optional</code>对象中的值为空，那么映射的结果也会是一个空的<code>Optional</code>对象。这就导致了在后续的操作中需要进行繁琐的 null 检查。</p></blockquote><h3 id="排序">排序</h3><table><thead><tr><th>API</th><th>功能说明</th></tr></thead><tbody><tr><td>sorted()</td><td>按照自然序排序（升序）</td></tr><tr><td>sorted(Comparator com)</td><td>按照给定的比较器排序</td></tr></tbody></table><h3 id="合并">合并</h3><table><thead><tr><th>API</th><th>功能说明</th></tr></thead><tbody><tr><td>concat()</td><td>将两个流的数据合并成一个新的流</td></tr></tbody></table><h3 id="处理">处理</h3><table><thead><tr><th>API</th><th>功能说明</th></tr></thead><tbody><tr><td>peek()</td><td>对 Stream 流中的每个元素进行处理，返回处理后的 Stream</td></tr></tbody></table><h2 id="终止-Stream-流">终止 Stream 流</h2><p>通过终止管道后，Stream 流会结束，一般在返回时会做一些操作，返回处理后的结果。注意，流结束时候一般不能再次使用（可以使用 <code>Supplier</code> 包装流，通过 <code>get</code> 方法构建新的流来实现流的复用）。</p><h3 id="匹配-查找">匹配/查找</h3><table><thead><tr><th>API</th><th>功能说明</th></tr></thead><tbody><tr><td>allMatch(Predicate p)</td><td>检查是否匹配所有元素，返回 boolean</td></tr><tr><td>anyMatch(Predicate P)</td><td>检查是否至少匹配一个元素，返回 boolean</td></tr><tr><td>noneMatch(Predicate p)</td><td>检查时候没有匹配所有元素，返回 boolean</td></tr><tr><td>findFirst()</td><td>返回第一个符合条件的元素</td></tr><tr><td>findAny()</td><td>返回当前流中符合条件的任意元素（串行流与 findFirst 相同，并行流时更加高效）</td></tr><tr><td>count()</td><td>返回流中的元素总数</td></tr><tr><td>max(Comparator c)</td><td>返回流中的最大值</td></tr><tr><td>min(Comparator c)</td><td>返回流中的最小值</td></tr><tr><td>forEach(Consumer c)</td><td>无返回值，对元素进行逐个遍历，执行给定的处理逻辑</td></tr></tbody></table><h4 id="peek-与-forEach">peek 与 forEach</h4><p><code>peek</code> 和 <code>forEach</code> 都可以对每个元素进行逐个处理。</p><p>但是 <code>peek</code> 属于中间方法，peek 操作完之后还是一个 Stream 流，而 <code>forEach</code> 属于终止方法，执行之后 Stream 流就没有了。根据前面提到的，如果想要看到处理结果，要么使用 <code>peek</code> + 一个终止方法或者使用 <code>forEach</code> 方法。</p><h3 id="归约">归约</h3><table><thead><tr><th>API</th><th>功能说明</th></tr></thead><tbody><tr><td>reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值，返回 Optional<T></td></tr><tr><td>reduce(T iden, BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值，返回 T</td></tr><tr><td>reduce(T iden, BiFunction acc, BinaryOperator b)</td><td>规定累加器，将多个结果合并为一个结果。</td></tr></tbody></table><p>例如，计算元素的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; sumOptional = numbers.stream().reduce((a, b) -&gt; a + b);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sumOptional.orElse(<span class="number">0</span>);</span><br><span class="line">System.out.println(sum); <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure><p>第一种方法接收 <code>BinaryOperator</code> 参数，这个参数用于将 Stream 中的元素合并为一个结果，在上述代码中，使用 Lambda 表达式将两个元素相加，最后返回累计和。</p><p>如果我们不想要得到 Optional 对象，可以使用如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line">System.out.println(sum); <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure><p>第二种方法接收一个初始值和一个 <code>BinaryOperator</code> 参数。使用初始值 0 即可避免返回 <code>Optional</code> 对象，这个初始值的类型与元素类型要保持一致。</p><p>此外还可以规定累加器方法，例如，求学生的成绩总和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">socreSum</span> <span class="operator">=</span> students</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce(<span class="number">0</span>, (sum, s) -&gt; sum += s.score, (sum1, sum2) -&gt; sum1 + sum2);</span><br></pre></td></tr></table></figure><p>不过这种方法一般结合并行流使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">socreSum</span> <span class="operator">=</span> students</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>, (sum, s) -&gt; sum += s.score, (sum1, sum2) -&gt; sum1 + sum2);</span><br></pre></td></tr></table></figure><h3 id="收集">收集</h3><table><thead><tr><th>API</th><th>功能描述</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其他形式（List、Map 等）。接收一个 Collector 接口实现，用于给 Stream 中给的元素做汇总的方法</td></tr><tr><td>toArray()</td><td>将 Stream 流转为数组</td></tr></tbody></table><h4 id="collection">collection</h4><p>当我们在使用 Stream 时，通常为了获取其结果是 List / Map 类型时，就需要用到 collection。</p><p><code>collect</code> 方法用于将流中的元素放到一个集合。</p><p>例如下面代码，将字符串列表元素放入一个新的列表中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamCollectExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;grape&quot;</span>);</span><br><span class="line">        List&lt;String&gt; result = list.stream()</span><br><span class="line">                .filter(s -&gt; s.length() &gt; <span class="number">5</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[banana, orange]</span><br></pre></td></tr></table></figure><p><code>collect</code> 还提供了其他收集器，如 <code>toMap()</code>、<code>toSet()</code> 等。</p><p>还有 <code>Collectors.groupingBy()</code> 等用来分组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;grape&quot;</span>);</span><br><span class="line">    Map&lt;Character, List&lt;String&gt;&gt; result = list.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(s -&gt; s.charAt(<span class="number">0</span>)));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a=[apple], b=[banana], o=[orange], p=[pear], g=[grape]&#125;</span><br></pre></td></tr></table></figure><p>可以看到，输出结果中按照首字母进行分组。<code>groupingBy</code> 方法还支持多条件分组，根据实际情况选择。</p><p>还有 <code>counting()</code> 等用来进行归约操作，实际 JDK 为了方便提供了归约逻辑的封装，如 <code>count()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamMaxByExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 collect() 方法找到最大值</span></span><br><span class="line">        Optional&lt;Integer&gt; max1 = list.stream().collect(Collectors.maxBy(Integer::compareTo));</span><br><span class="line">        System.out.println(max1.get());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接使用 max() 方法找到最大值</span></span><br><span class="line">        Optional&lt;Integer&gt; max2 = list.stream().max(Integer::compareTo);</span><br><span class="line">        System.out.println(max2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，使用 <code>collect()</code> 方法和 <code>max()</code> 方法都可以找到该流中的最大值，但是使用 <code>max()</code> 方法可以更加简化代码，同时也更加直观易懂。因此，在实际开发中，我们可以根据实际需求选择合适的方法来实现相应的功能。</p><h2 id="并行-Stream">并行 Stream</h2><p>Stream API 还为我们提供了并行处理 Stream 的方式，通过 <code>parallelStream</code> 方法或者 <code>parallel</code> 方法创建并行 Stream 对象。</p><p>并行流底层使用的是 <code>ForkJoinPool</code>，线程池的大小最多为 5 个，具体取决于 CPU 的核心数。ForkJoin 框架采用分治策略，你还可以自定义线程池，不过一般情况下默认的也够用了。</p><p>并行流对含有大量元素的数据时性能提升很大，但同时要注意，在使用并行时会有额外的组合操作，这部分也会花费一定的时间。</p><p><strong>使用细节及注意事项</strong></p><ol><li>必须在多核 CPU 的主机上使用；</li><li>当数据量不大时，串行 Stream 和并行 Stream 性能相差不大，无需使用并行 Stream；</li><li>因为并行计算依赖 CPU，所以 CPU 密集型计算适合并行 Stream，而 IO 密集型使用时因多个线程频繁切换反而会更慢；</li><li>当需要使用 collect 合并的时候，合并时间可能会很长，不适合使用并行 Stream；</li><li>例如 limit、findFirst 等依赖元素顺序的操作不适合使用并行 Stream；</li><li>类似于多线程场景，可能会产生死锁问题，所以要保证线程安全。</li></ol><p>总之，在使用并行 Stream 之前最好先实践一下是否能提高性能。</p><p><strong>参考</strong></p><p>【1】<a href="https://juejin.cn/post/6844904184953700360">8000字长文让你彻底了解 Java 8 的 Lambda、函数式接口、Stream 用法和原理 - 掘金 (juejin.cn)</a></p><p>【2】<a href="https://juejin.cn/post/7118991438448164878?searchId=2023093014585876B591EDB3B0371C21F1#heading-1">吃透JAVA的Stream流操作，多年实践总结 - 掘金 (juejin.cn)</a></p><p>【3】<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#NonInterference">java.util.stream (Java Platform SE 8 ) (oracle.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;什么是 Stream&lt;/h1&gt;
&lt;h2 id=&quot;Stream-简介&quot;&gt;Stream 简介&lt;/h2&gt;
&lt;p&gt;在处理集合数据时，常常需要对其进行各种操作，例如过滤、映射、规约等。而 Java 8 中引入的 Stream 流为我们提供一种更加简洁和灵活的方式来处理数据。&lt;/p&gt;</summary>
      
    
    
    
    <category term="notes" scheme="https://yocy.top/categories/notes/"/>
    
    
    <category term="笔记" scheme="https://yocy.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="https://yocy.top/tags/Java/"/>
    
    <category term="Stream" scheme="https://yocy.top/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你学会二分算法</title>
    <link href="https://yocy.top/post/5d8f8dd1.html"/>
    <id>https://yocy.top/post/5d8f8dd1.html</id>
    <published>2023-08-27T15:57:19.000Z</published>
    <updated>2023-08-27T18:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Um_nik: Stop learning useless algorithms, go and solve some problems, learn how to use binary search!</p></blockquote><h1>1、基本概述</h1><p>二分算法的基本用法是在一个单调有序的集合或函数中查找一个解。因此，当问题的答案具有单调性时，可以考虑将问题的解，通过二分，转化为某种判定问题。每次分成左右两个区间，通过判断调整上下界，即继续搜索左区间还是右区间，直到找到目标元素。</p><p>更进一步的说，还可以扩展到三分算法取解决峰值函数的极值问题。三分算法将区间分成 3 个部分，可以明确判断答案不在哪一部分，舍弃三分之一的空间，继续进行查找。</p><p>此外，还有浮点数上的二分，其与整数二分大同小异。</p><p>总结一下，一般初学者在练习时可能会碰到以下问题：</p><ul><li>整数集上的二分，需要注意左右区间的开闭情况，避免漏掉答案或者死循环；</li><li>实数域上的二分，需要注意精度问题。</li></ul><p>二分的实现方法灵活多样，主要是处理边界上的差异时需要仔细考虑。为了避免混淆写法，下面只着重介绍一种实现方法。</p><h1>2、算法实现</h1><h2 id="2-1、整数集上的二分">2.1、整数集上的二分</h2><p>本文介绍的写法保证答案在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间内，且当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l = r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 时，循环退出，每次的二分中值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 只属于左右区间的其中之一。</p><p>举个例子，比如我们要查找区间中最小的大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的元素（即结果是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的后继）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= x) &#123;</span><br><span class="line">        r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">a[mid] &gt; x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，根据单调性，则在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 后的元素比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 更大。所以我们下一次查找的是左半段，即缩小上界 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>；如果相等时，和上面的情况相同，下一次要查找的也是左半段，故合并在一起写成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>≥</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">a[mid] \ge x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，因为要保证答案始终在区间内，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 此时可能是解，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">r = mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>，让边界取到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>。</p><p><img src="/imgs/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/tstmp_20230626000404.gif" alt="erfen_01"></p><p>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">a[mid] &lt; x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，可知此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 一定不是我们的解，故 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l = mid + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，抛弃左半段。</p><p><img src="/imgs/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/tstmp_20230625235832.gif" alt="erfen_02"></p><p>相信上面的解释已经让你有些了解二分的基本思路。下面再举一个例子，在不降序列中查找小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的最大的一个（即结果是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的前驱）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &lt;= x) &#123;</span><br><span class="line">        l = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试按照上面的步骤，自己解释一下上述代码。</p><hr><p>可见这个二分写法有两种形式：</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>l</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r = mid,l=mid + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，对于中间值，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><mi>l</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mid =  (l + r) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span>；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>r</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l = mid, r = mid - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，对于中间值，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><mi>l</mi><mo>+</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mid = (l + r + 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span>。</li></ol><p>为什么要区分 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 的形式呢？</p><p>主要是因为要避免死循环。假如让形式2为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><mi>l</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mid = (l + r) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span>，那么当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 相邻时，就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">⌋</mo><mo>=</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">mid = \lfloor\frac{l+r}{2}\rfloor = l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>，若接下来进入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">l = mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 分支，就会造成死循环；若进入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r = mid-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 这个分支，则循环退出时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>&gt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l &gt; r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，答案不在区间内。所以这样区分是有必要的。</p><p>这种写法比较灵活，其好处是循环退出的条件是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l = r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，也就是不用考虑最后的答案到底是在左端点还是右端点。</p><p>为了进一步加深理解，我们观察这两种形式，不难发现：主要是查找到两个<strong>相邻的</strong>两个值时，先去判断左端点还是右端点，前者先判断的是左端点，后者先判断的是右端点。所以我们可以利用这个特点，来决定具体采用那哪种形式。</p><p>例如，如果我们要找的是最大的一个解，那么在二分查找的过程中，区间会不断缩小，直至两个端点相邻。此时，先去判断较大的那个端点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 不满足条件，就让 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r = mid - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，也就是说排除这个右端点，否则就让 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">l = mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>。如果要找的是最小的一个解也是同理。</p><p>此外，我们也可以利用这一特点，发现：形式1不会取到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，形式2不会取到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>。因此，我们可以扩展原来的区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,n+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>。扩大边界的好处是：如果目标不在我们查找的区间中，则最后位置一定在我们额外扩充的边界上，此时说明区间内不存在解。</p><p>总结一下吧，这种写法的基本流程是：</p><ol><li>通过分析问题，确定对于 <code>mid</code>，下一次要查找的是左半段还是右半段，以及 <code>mid</code> 保留在哪一个半段；</li><li>根据分析结果，确定 <code>mid</code> 是用哪种形式，相邻时先判断右端点还是左端点；</li><li>循环退出的条件是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l = r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，所以最后答案任意输出其中一个即可。</li></ol><hr><p>这里提一下 C++ STL 中的两个函数 <code>upper_bound</code> 和 <code>lower_bound</code>，分别是查找第一个大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的元素和第一个大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的元素。</p><p>这里总结了以下情况：</p><ol><li>查找第一个大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的元素的位置：<code>upper_bound()</code>。例如，<code>pos = upper_bound(a, a + n, x) - a</code>；</li><li>查找第一个大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的元素的位置：<code>lower_bound()</code>；</li><li>查找第一个与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 相等的元素：<code>lower_bound()</code> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>；</li><li>查找最后一个与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 相等的元素：<code>upper_bound()</code> 的前一个且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>；</li><li>查找最后一个小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的元素：<code>upper_bound()</code> 的前一个；</li><li>查找最后一个小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的元素：<code>lower_bound()</code> 的前一个。</li></ol><p><a href="https://www.apiref.com/cpp-zh/cpp/algorithm.html">C++ API STL算法库参考文档</a></p><h2 id="2-2、实数域上的二分">2.2、实数域上的二分</h2><p>也叫浮点二分，与整数集上的二分的写法大同小异，主要考虑精度问题。一般题目会给出保留小数位数或误差范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。定义一个 <code>EPS</code> 常量为 <code>1e-12</code>（具体根据题目设置），循环退出的条件由原来的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>&lt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l &lt; r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 改为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><mi>e</mi><mi>p</mi><mi>s</mi><mo>&lt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l + eps &lt; r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 不区分形式，只有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><mi>l</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mid = (l + r) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l + eps &lt; r) &#123;</span><br><span class="line">     mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">     <span class="keyword">else</span> r = mid;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此外，还有种固定循环次数的写法，不过这种写法一般不太会用到，主要是针对有些题目精度没有明确给出时使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">     mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">     <span class="keyword">else</span> r = mid;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3、三分求凸性函数极值">2.3、三分求凸性函数极值</h2><p>凸性函数即在区间内是单峰函数，有唯一的极大值或极小值点（只能选其一）。</p><p>实现的思路是：对于一个开口向下的函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>,在定义域 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 内，取两个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">lmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">rmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>，从而将整个函数分成了三段。</p><ol><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(lmid) &lt; f(rmid)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">lmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">rmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 同时在极大值的左侧，或是一个在左一个在右。无论是哪种情况，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">lmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>一定是在极大值的左侧，所以让 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mi>l</mi><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">l = lmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>；</li><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(lmid) &gt; f(rmid)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">lmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">rmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 同时在极大值的右侧，或是一个在左一个在右。无论是哪种情况，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">rmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span> 一定是在极大值的右侧，所以让 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>r</mi><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">r = rmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>；</li><li>通过上述的两个过程，区间不断往极大值逼近，最终求的解。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (l + eps &lt; r) &#123;</span><br><span class="line">     lmid = l + (r - l) / <span class="number">3.0</span>;</span><br><span class="line">     rmid = r - (r - l) / <span class="number">3.0</span>；</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">f</span>(lmid) &lt; <span class="built_in">f</span>(rmid)) l = lmid;</span><br><span class="line">     <span class="keyword">else</span> r = rmid;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1>3、例题讲解</h1><h2 id="3-1、整数集上的二分">3.1、整数集上的二分</h2><h3 id="3-1-1、寻找指定和的整数对">3.1.1、寻找指定和的整数对</h3><h4 id="问题描述">问题描述</h4><p>输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，找出其中的两个数，它们的和等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p><h4 id="题解">题解</h4><p>采用暴力的做法是用嵌套循环，枚举出所有的情况，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p>采用二分算法优化查找。首先要确保序列的单调性，所以对数组进行排序。在查找的过程中，假设当前的数字是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，查找在该数字后是否存在一个数字的值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m - a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 即可。因为数组是单调的，所以可以用二分优化查找第一个等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m - a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的值。排序直接用 STL 中的 <code>sort</code> 函数，所以最后整个算法的复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h4 id="练习：P1102-A-B-数对-洛谷-luogu-com-cn">练习：<a href="https://www.luogu.com.cn/problem/P1102">P1102 A-B 数对 - 洛谷(luogu.com.cn)</a></h4><h2 id="3-2、实数集上的二分">3.2、实数集上的二分</h2><h3 id="3-2-1、小车问题">3.2.1、小车问题</h3><h4 id="问题描述-2">问题描述</h4><p>两人一车，人比车快，求它们从 A 到 B 的最短时间。</p><h4 id="题解-2">题解</h4><p>假设甲、乙两人甲先坐车，乙走路。</p><p>不难想到最短的时间是两人同时出发，车先带甲到半路，然后让甲自己走到终点，车子再回去接乙，最终两人同时到达终点。此时花费的时间就是最少的时间。所以问题的关键是找到这个车子折返点。</p><p>简单分析一下，如果折返点距离起点越远，那么乙花费的时间就越长；如果折返点距离起点越近，那么甲花费的时间就越长。因此可以发现距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 与花费时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 有单调关系。因此可以用二分来解决。</p><p>具体做法是枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，然后分别计算甲、乙到达终点的时间，如果甲先到达，那么就缩短其坐车的时间，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">r = mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>；否则就增加其坐车的时间，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">l = mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span></span></span></span>。最终计算出两者到达终点时间相同，就是最短的时间。时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h4 id="练习：P1258-小车问题-洛谷-luogu-com-cn">练习：<a href="https://www.luogu.com.cn/problem/P1258">P1258 小车问题 - 洛谷 (luogu.com.cn)</a></h4><h2 id="3-3、二分答案">3.3、二分答案</h2><h3 id="3-3-1、Balanced-Stone-Heaps">3.3.1、Balanced Stone Heaps</h3><h4 id="问题描述-3">问题描述</h4><p>有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 堆石头，每堆石头有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个石头。你可以通过以下操作该改变每堆石头的数量：</p><ul><li>从第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 堆石头开始操作，直到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 堆石头；</li><li>假设当前是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 堆石头，可以选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> 个石头移到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 堆，同时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>d</mi></mrow><annotation encoding="application/x-tex">2d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">2</span><span class="mord mathnormal">d</span></span></span></span> 个石头移到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 堆，所以如果这样操作之后，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 堆减少了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mi>d</mi></mrow><annotation encoding="application/x-tex">3d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">3</span><span class="mord mathnormal">d</span></span></span></span> 个石头。</li><li>每次操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mn>3</mn><mi>d</mi><mo>≤</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">0\le 3d\le h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord">3</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul><p>求操作之后最少石头的那堆的最大值。</p><h4 id="题解-3">题解</h4><p>对最小高度二分。对于当前假设的高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，每次操作的时候，采取贪心策略，倒序枚举，把当前的石头数尽可能地放到前两堆。需要注意的是，当前堆石头数减少的数量一定是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 或是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 的正整数倍数。</p><h4 id="练习：Problem-1623C-Codeforces">练习：<a href="https://codeforces.com/contest/1623/problem/C">Problem - 1623C - Codeforces</a></h4><h2 id="3-4、三分">3.4、三分</h2><h3 id="3-4-1、Error-Curves">3.4.1、Error Curves</h3><h4 id="问题描述-4">问题描述</h4><p>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x) = max(S_i(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_i(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 是二次函数，你需要找出最大的二次函数的最小值。</p><h4 id="题解-4">题解</h4><p>二次函数在定义域内找出极值用三分即可。然后再取最大值。</p><h4 id="练习：Problem-3714-hdu-edu-cn">练习：<a href="https://acm.hdu.edu.cn/showproblem.php?pid=3714">Problem - 3714 (hdu.edu.cn)</a></h4><h1>4、习题推荐</h1><ol><li><a href="https://codeforces.com/problemset/problem/1443/C">Problem - 1443C - Codeforces</a></li><li><a href="https://codeforces.com/problemset/problem/1408/C">Problem - 1408C - Codeforces</a></li><li><a href="https://codeforces.com/problemset/problem/626/C">Problem - 626C - Codeforces</a></li><li><a href="https://codeforces.com/problemset/problem/371/C">Problem - 371C - Codeforces</a></li><li><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2899">Problem - 2899 (hdu.edu.cn)</a></li><li><a href="https://acm.hdu.edu.cn/showproblem.php?pid=4004">Problem - 4004 (hdu.edu.cn)</a></li><li><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2289">Problem - 2289 (hdu.edu.cn)</a></li><li><a href="https://codeforces.com/gym/102470/problem/A">Problem - A - Codeforces</a></li><li><a href="https://codeforces.com/problemset/problem/1486/D">Problem - 1486D - Codeforces</a></li><li><a href="https://codeforces.com/problemset/problem/1119/D">Problem - 1119D - Codeforces</a></li><li><a href="https://codeforces.com/problemset/problem/1199/C">Problem - 1199C - Codeforces</a></li><li><a href="https://codeforces.com/problemset/problem/1041/D">Problem - 1041D - Codeforces</a></li><li><a href="https://codeforces.com/problemset/problem/1370/D">Problem - 1370D - Codeforces</a></li><li><a href="https://codeforces.com/problemset/problem/1260/D">Problem - 1260D - Codeforces</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Um_nik: Stop learning useless algorithms, go and solve some problems, learn how to use binary search!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;</summary>
      
    
    
    
    <category term="notes" scheme="https://yocy.top/categories/notes/"/>
    
    
    <category term="笔记" scheme="https://yocy.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://yocy.top/tags/C/"/>
    
    <category term="ACM/ICPC" scheme="https://yocy.top/tags/ACM-ICPC/"/>
    
    <category term="二分" scheme="https://yocy.top/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="算法" scheme="https://yocy.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6的对象扩展对算符</title>
    <link href="https://yocy.top/post/da270316.html"/>
    <id>https://yocy.top/post/da270316.html</id>
    <published>2023-08-25T11:58:53.000Z</published>
    <updated>2023-08-27T18:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、基本介绍</h1><p>扩展运算符：<code>...</code></p><p>它是 ES6 的语法，用于将取出参数对象，然后<strong>拷贝</strong>到当前对象中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;youngcy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o);     <span class="comment">// &#123; name: &#x27;youngcy&#x27;, age: 21 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;...o&#125;);<span class="comment">// &#123; name: &#x27;youngcy&#x27;, age: 21 &#125;</span></span><br></pre></td></tr></table></figure><h1>2、使用技巧</h1><h2 id="2-1、对象合并">2.1、对象合并</h2><p>语法：<code>mergeObject = &#123;...o1, ...o2, ...o3, ...o4&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;youngcy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> o3 = &#123;</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">35</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;...o1, ...o2&#125;);    <span class="comment">// &#123; name: &#x27;youngcy&#x27;, age: 21, gender: &#x27;男&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;...o1, ...o2, ...o3&#125;);     <span class="comment">// &#123; name: &#x27;youngcy&#x27;, age: 35, gender: &#x27;女&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;...o2, ...o3&#125;);    <span class="comment">// &#123; gender: &#x27;女&#x27;, age: 35 &#125; </span></span><br></pre></td></tr></table></figure><p>从上面也可以看出，如果合并的对象有相同的键名，那么后面对象的键值会覆盖之前对象的键值。</p><h2 id="2-2、对象拷贝">2.2、对象拷贝</h2><p>语法：<code>newObject = &#123;...Object&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;youngcy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o2 = o1;</span><br><span class="line"><span class="keyword">let</span> o3 = &#123;...o1&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2, o1 === o2);     <span class="comment">// &#123; name: &#x27;youngcy&#x27;, age: 21 &#125; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o3, o1 === o3);     <span class="comment">// &#123; name: &#x27;youngcy&#x27;, age: 21 &#125; false</span></span><br></pre></td></tr></table></figure><p>需要注意的是，扩展运算符<strong>不执行深拷贝</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;youngcy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="attr">hobby</span>: [</span><br><span class="line">    <span class="string">&#x27;羽毛球&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;打音游&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o2 = &#123;...o1&#125;;</span><br><span class="line">o2.<span class="property">age</span> = <span class="number">35</span>;</span><br><span class="line">o2.<span class="property">hobby</span>.<span class="title function_">push</span>(<span class="string">&#x27;敲代码&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1);<span class="comment">// &#123; name: &#x27;youngcy&#x27;, age: 21, hobby: [ &#x27;羽毛球&#x27;, &#x27;打音游&#x27;, &#x27;敲代码&#x27; ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2);<span class="comment">// &#123; name: &#x27;youngcy&#x27;, age: 35, hobby: [ &#x27;羽毛球&#x27;, &#x27;打音游&#x27;, &#x27;敲代码&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-3、解构变量">2.3、解构变量</h2><p>语法：<code>&#123; arg1, ...others &#125; = oldObject</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;youngcy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, ...others &#125; = o1;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);      <span class="comment">// youngcy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(others);    <span class="comment">// &#123; age: 21, gender: &#x27;男&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-4、传递参数">2.4、传递参数</h2><p>上面的解构同样可以用来解构数组，因此可以用来传递参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayNumbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...arrayNumbers);</span><br><span class="line"><span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...arrayNumbers);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(min);<span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(max);<span class="comment">// 10</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Math.min()</code> 和 <code>Math.max()</code> 方法需要传入一系列参数，而不是一个数组。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1、基本介绍&lt;/h1&gt;
&lt;p&gt;扩展运算符：&lt;code&gt;...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它是 ES6 的语法，用于将取出参数对象，然后&lt;strong&gt;拷贝&lt;/strong&gt;到当前对象中。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;</summary>
      
    
    
    
    <category term="notes" scheme="https://yocy.top/categories/notes/"/>
    
    
    <category term="笔记" scheme="https://yocy.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="前端" scheme="https://yocy.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="javascript" scheme="https://yocy.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Axios携带cookie时的跨域问题</title>
    <link href="https://yocy.top/post/2dc1c39b.html"/>
    <id>https://yocy.top/post/2dc1c39b.html</id>
    <published>2023-08-10T19:49:16.000Z</published>
    <updated>2023-08-10T16:02:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>用户个人界面通过携带 cookie 发送给后端，后端根据这个 cookie 再返回数据给前端。为了使得前端发送的请求中携带 cookie，只需要在 myAxios.ts 中添加 <code>myAxios.defaults.withCredentials = true;</code>。但是随即登录出现了跨域问题。</p><p><img src="/imgs/posts/Axios%E6%90%BA%E5%B8%A6cookie%E6%97%B6%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20230810180739627.png" alt=""></p><p>后端的 Controller 层已用 <code>@CrossOrigin</code> 注解，但仍然存在跨域问题。</p><p><img src="/imgs/posts/Axios%E6%90%BA%E5%B8%A6cookie%E6%97%B6%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20230810191510213.png" alt="image-20230810191510213"></p><h3 id="产生原因">产生原因</h3><p>查看 <code>CrossOrigin</code> 注解，可以发现默认参数 <em>DEFAULT_ALLOW_CREDENTIALS</em> 为 <code>false</code>，导致后端不能接收到 cookie。</p><p><img src="/imgs/posts/Axios%E6%90%BA%E5%B8%A6cookie%E6%97%B6%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20230810193950798.png" alt="image-20230810193950798"></p><h3 id="解决办法">解决办法</h3><p>解决的办法有两种：</p><ol><li><p>在 <code>@CrossOrigin</code> 注解中添加 <code>allowCredentials = &quot;true&quot;</code>。</p></li><li><p>删除 <code>@CrossOrigin</code> 注解，添加 <code>WebMvcConfig</code> 类，允许所有的请求跨域访问或者指定特定的请求路径进行跨域访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:3000&quot;</span>) <span class="comment">// 允许访问的域</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>) <span class="comment">// 允许的请求方法</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>) <span class="comment">// 是否允许发送Cookie信息</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>); <span class="comment">// 预检请求的有效期，单位为秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>另外需要注意的是，浏览器的同源策略可能不同，例如谷歌不能将127.0.0.1映射到localhost，所以需要保证尽量前后端的路径一致！！！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用户个人界面通过携带 cookie 发送给后端，后端根据这个 cookie 再返回数据给前端。为了使得前端发送的请求中携带 cookie，只需要在 myAxios.ts 中添加 &lt;code&gt;myAxios.defaults.withCredentials = true;&lt;/</summary>
      
    
    
    
    <category term="notes" scheme="https://yocy.top/categories/notes/"/>
    
    
    <category term="跨域问题" scheme="https://yocy.top/tags/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    
    <category term="后端" scheme="https://yocy.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="笔记" scheme="https://yocy.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS7中安装MySQL数据库</title>
    <link href="https://yocy.top/post/702c7f12.html"/>
    <id>https://yocy.top/post/702c7f12.html</id>
    <published>2023-07-06T10:03:14.000Z</published>
    <updated>2023-07-09T06:10:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1>MySQL 安装</h1><p>本文基于 CentOS 7.9 系统进行安装。</p><h2 id="1-准备安装包">1. 准备安装包</h2><p>这里准备的是 <code>mysql-8.0.33-linux-glibc2.12-x86_64.tar.xz</code>，并将其直接放在了 <code>/root</code> 目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.33-linux-glibc2.12-x86_64.tar.xz</span></span><br></pre></td></tr></table></figure><p>注意这里的 <code>glibc2.12</code>，是安装 MySQL 所需的的 glibc 版本，在安装之前先输入 <code>rpm -q glibc</code> ，查看本系统的 glibc 版本，安装的版本不能高于系统的版本，否则需要自行下载在配置（比较麻烦，不推荐）。</p><h2 id="2-卸载系统⾃带的-MARIADB">2. 卸载系统⾃带的 MARIADB</h2><p>输入 <code>rpm -qa|grep mariadb</code> 检查是否有 mariadb，它会和 MySQL 冲突，如果没有则可以跳过此步骤。</p><p><img src="/imgs/posts/%E5%9C%A8CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/image-20230517140915613.png" alt="image-20230517140915613"></p><p>输入如下命令卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum -y remove mariadb-libs-5.5.68-1.el7.x86_64</span></span><br></pre></td></tr></table></figure><h2 id="3-解压-MySQL-安装包">3. 解压 MySQL 安装包</h2><p>输入如下命令，将安装包解压至 <code>/usr/local/</code> 目录，并将目录重命名为 <code>mysql</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># tar -xJvf /root/mysql-8.0.33-linux-glibc2.12-x86_64.tar.xz -C /usr/local</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd /usr/local</span></span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># mv mysql-8.0.33-linux-glibc2.12-x86_64 mysql</span></span><br></pre></td></tr></table></figure><h2 id="4-创建-MySQL-用户和-MySQL-用户组">4. 创建 MySQL 用户和 MySQL 用户组</h2><p>输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># groupadd mysql</span></span><br><span class="line">[root@localhost ~]<span class="comment"># useradd -g mysql mysql</span></span><br></pre></td></tr></table></figure><p>同时，新建 <code>/usr/local/mysql/data</code> ，便于后续配置，该文件夹用来存放 MySQL 的数据文件。</p><h2 id="5-修改-MySQL-目录的归属用户">5. 修改 MySQL 目录的归属用户</h2><p>输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># chown -R mysql:mysql ./ </span></span><br></pre></td></tr></table></figure><h2 id="6-创建-MySQL-的配置文件">6. 创建 MySQL 的配置文件</h2><p>首先在 <code>/etc</code> 目录下新建 <code>my.cnf</code> 文件。</p><p>然后在该文件写入如下配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"><span class="attr">socket</span>=/var/lib/mysql/mysql.sock</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line">skip-name-resolve</span><br><span class="line"><span class="comment">#设置3306端⼝</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">socket</span>=/var/lib/mysql/mysql.sock</span><br><span class="line"><span class="comment"># 设置mysql的安装⽬录</span></span><br><span class="line"><span class="attr">basedir</span>=/usr/local/mysql</span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放⽬录</span></span><br><span class="line"><span class="attr">datadir</span>=/usr/local/mysql/data</span><br><span class="line"><span class="comment"># 允许最⼤连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="comment"># 服务端使⽤的字符集默认为8⽐特编码的latin1字符集</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使⽤的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"><span class="attr">lower_case_table_names</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">max_allowed_packet</span>=<span class="number">16</span>M</span><br></pre></td></tr></table></figure><p>同时新建文件 <code>/var/lib/mysql</code>，并求改其权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /var/lib/mysql</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod 777 /var/lib/mysql</span></span><br></pre></td></tr></table></figure><h2 id="7-安装-MySQL">7. 安装 MySQL</h2><p>首先进入刚才解压的目录，也就是 <code>/usr/local/mysql</code> 目录，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /usr/local/mysql</span></span><br><span class="line">[root@localhost mysql]<span class="comment"># ./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data</span></span><br></pre></td></tr></table></figure><p><img src="/imgs/posts/%E5%9C%A8CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/image-20230517145641926.png" alt="image-20230517145641926"></p><p>记住这里的 MySQL 密码，待会儿登录数据库要用到。</p><h2 id="8-复制启动脚本到资源目录">8. 复制启动脚本到资源目录</h2><blockquote><p>❗注意：如果在你的服务器中已有 <code>mysqld</code> 服务，则将其改为其他名字即可解决冲突，例如改为 <code>mysqld2</code>，下面以 <code>mysqld</code> 做演示。</p></blockquote><p>执行如下命令进行复制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># cp ./support-files/mysql.server /etc/init.d/mysqld</span></span><br></pre></td></tr></table></figure><p>然后打开 <code>/etc/init.d/mysqld</code>，修改 <code>basedir</code> 和 <code>datadir</code> 的路径。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">basedir</span>=/usr/local/mysql</span><br><span class="line"><span class="attr">datadir</span>=/usr/local/mysql/data</span><br></pre></td></tr></table></figure><h2 id="9-设置-MYSQL-系统服务并开启⾃启">9. 设置 MYSQL 系统服务并开启⾃启</h2><p>首先增加 <code>mysqld</code> 的服务控制脚本执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># chmod +x /etc/init.d/mysqld</span></span><br></pre></td></tr></table></figure><p>将 <code>mysqld</code> 加入到系统服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># chkconfig --add mysqld</span></span><br></pre></td></tr></table></figure><blockquote><p>❗注意：如果你在这碰到了 <code>... ERROR! The server quit without updating PID file</code>，一般是因为端口冲突，修改 <code>/etc/my.cnf</code> 即可。</p></blockquote><p>最后检查 <code>mysqld</code> 服务是否生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># chkconfig --list mysqld</span></span><br></pre></td></tr></table></figure><p><img src="/imgs/posts/%E5%9C%A8CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/image-20230517151057250.png" alt="image-20230517151057250"></p><p>这样就说明 <code>mysqld</code>服务已经生效，在 2、3、4、5 运行级别随系统启动而自启，以后可以使用 <code>service</code> 命令控制 <code>mysql</code> 的开启与关闭。</p><h2 id="10-启动-MySQL">10. 启动 MySQL</h2><p>直接执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># service mysqld start</span></span><br></pre></td></tr></table></figure><p><img src="/imgs/posts/%E5%9C%A8CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/image-20230517152423748.png" alt="image-20230517152423748"></p><h2 id="11-将-MySQL-的-bin-目录加入到-PATH-环境变量">11. 将 MySQL 的 bin 目录加入到 PATH 环境变量</h2><p>为了方便以后在任意目录下都可以使用 MySQL 提供的命令，需要修改 <code>~/.bash_profile</code> 文件，直接在末尾追加如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mysql Config</span></span><br><span class="line">export PATH=$PATH:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><p>然后再执行 <code>source ~/.bash_profile</code> 使配置生效。</p><h2 id="12-登录-Mysql">12. 登录 Mysql</h2><p>以 root 账户登录 mysql，根据上文提示的密码进行登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># mysql -u root -p</span></span><br></pre></td></tr></table></figure><p><img src="/imgs/posts/%E5%9C%A8CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/image-20230517154150619.png" alt="image-20230517154150619"></p><h2 id="13-修改-root-账户的密码">13. 修改 root 账户的密码</h2><p>输入如下命令进行修改，这里将密码修改为 “123456”，可自行修改成其他密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter user user() identified by &quot;123456&quot;;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><h2 id="14-设置远程主机登录">14. 设置远程主机登录</h2><p>首先输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user set user.Host=&#x27;%&#x27; where user.User=&#x27;root&#x27;;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>这里使用 Navicat 进行测试。</p><p>输入虚拟机的 ip 地址（使用 <code>ip addr</code> 查看），然后输入 root 和刚才重新设置的密码，但是发现连接不上，这是因为我们还没有关闭防护墙。</p><p>输入命令关闭防火墙：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]<span class="comment"># systemctl stop firewalld</span></span><br></pre></td></tr></table></figure><p>如果是在服务器上，例如阿里云、腾讯云，则添加对应的防火墙规则。</p><p>查看防火墙规则命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --list-port</span><br></pre></td></tr></table></figure><p>添加端口规则后，再去阿里云控制台添加规则才能成功。</p><p>最后就可以看到连接成功了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;MySQL 安装&lt;/h1&gt;
&lt;p&gt;本文基于 CentOS 7.9 系统进行安装。&lt;/p&gt;
&lt;h2 id=&quot;1-准备安装包&quot;&gt;1. 准备安装包&lt;/h2&gt;
&lt;p&gt;这里准备的是 &lt;code&gt;mysql-8.0.33-linux-glibc2.12-x86_64.tar.xz&lt;/</summary>
      
    
    
    
    <category term="notes" scheme="https://yocy.top/categories/notes/"/>
    
    
    <category term="笔记" scheme="https://yocy.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库" scheme="https://yocy.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="工具相关" scheme="https://yocy.top/tags/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS7中安装Git工具</title>
    <link href="https://yocy.top/post/22c79ab0.html"/>
    <id>https://yocy.top/post/22c79ab0.html</id>
    <published>2023-05-20T10:03:14.000Z</published>
    <updated>2023-07-08T01:16:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Git 工具安装</h1><h2 id="方式一：通过包管理器安装">方式一：通过包管理器安装</h2><p>在 Linux 上安装 Git 只需要一行命令即可搞定，在 CentOS 系统中，执行如下命令即可安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum install git</span></span><br></pre></td></tr></table></figure><p>当然通过这种这种方式安装的不是最新版本的 Git，以本实验环境 CentOS 7.9 来说，这种方式安装的 Git 版本为 <code>1.8.3.1</code>，一般来讲是够用的。</p><p><img src="https://bu.dusays.com/2023/05/21/6469ec16ab909.png" alt="image-20230509010615583.png"></p><h2 id="方式二：通过源码编译安装">方式二：通过源码编译安装</h2><p>如果想要安装最新版本的 Git，需要自行下载 Git 源码来编译安装。</p><p><a href="https://git-scm.com/download">https://git-scm.com/download</a></p><h3 id="1-准备-Git-安装包">1. 准备 Git 安装包</h3><p>这里选择的是 <code>2.40.1</code> 版，将下载好的安装包 <code>git-2.40.1</code> 放在 <code>root</code> 目录下，然后解压，得到 <code>git-2.40.1</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># tar -zxvf git-2.40.1.tar.gz</span></span><br></pre></td></tr></table></figure><h3 id="2-提前装好可能需要的依赖">2. 提前装好可能需要的依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum install curl-devel expat-devel gettext-devel openssl-devel zlibdevel gcc-c++ perl-ExtUtils-MakeMaker</span></span><br></pre></td></tr></table></figure><h3 id="3-编译安装-Git">3. 编译安装 Git</h3><p>首先进入对应的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd git-2.40.1</span></span><br></pre></td></tr></table></figure><p>执⾏配置、编译、安装命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost git-2.40.1]<span class="comment"># make all profix=/usr/local/git</span></span><br><span class="line">[root@localhost git-2.40.1]<span class="comment"># make install profix=/usr/local/git</span></span><br></pre></td></tr></table></figure><p>其中，<code>--prefix=...</code> 会指定软件的安装目录，上述命令会将编译后的二进制文件放在 <code>/usr/local/git</code> 募目录下。</p><h3 id="4-将-Git-加入环境变量">4. 将 Git 加入环境变量</h3><p>将 Git 可执行程序加入环境变量。</p><p>编辑配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/profile</span></span><br></pre></td></tr></table></figure><p>在尾部加入 Git 的 bin 路径配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Git config</span></span><br><span class="line">export GIT_HOME=/usr/local/git</span><br><span class="line">export PATH=$PATH:$GIT_HOME/bin</span><br></pre></td></tr></table></figure><p>最后执行 <code>source /etc/profile</code> 使环境变量生效。</p><h3 id="5-验证配置结果">5. 验证配置结果</h3><p>执行 <code>git --version</code> 查看安装后的版本。</p><p>但是可能会出现如下问题。</p><p><img src="/imgs/posts/%E5%9C%A8CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85Git%E5%B7%A5%E5%85%B7/image-20230509013939859.png" alt="image-20230509013939859"></p><p>查看系统的 <code>PATH</code> 变量。</p><p><img src="/imgs/posts/%E5%9C%A8CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85Git%E5%B7%A5%E5%85%B7/image-20230509014049603.png" alt="image-20230509014049603"></p><p>可以看到 <code>PATH</code> 变量是对的，在查看 Git 的路径。</p><p><img src="/imgs/posts/%E5%9C%A8CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85Git%E5%B7%A5%E5%85%B7/image-20230509014216910.png" alt="image-20230509014216910"></p><p>发现此时 Git 的路径并不对，这是因为 <code>/usr/bin/</code> 出现在 <code>PATH</code> 环境变量中的位置优先级会比 <code>/usr/local/git/bin</code> 要高，所以系统会优先显示旧版本的的 Git。</p><p>解决的办法一般有如下两种：</p><ol><li><p>编写 <code>.bash_profile</code> 文件（<strong>推荐</strong>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>然后再末尾添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use git-2.40.1</span></span><br><span class="line">export PATH=/usr/local/git/bin:$PATH</span><br></pre></td></tr></table></figure><p>保存并退出文件，然后输入 <code>source ~/.bash_profile</code> 使配置生效。</p></li><li><p>删除旧版本 Git</p><p>因为我们的旧版本 Git 是通过包管理工具安装的，所以直接输入 <code>yum remove git</code> 即可。</p></li></ol><p>当然也可以建立软链接来链接到我们的 Git 路径，但是比较麻烦。这里更推荐办法1的原因是操作简单，而且也不需要对系统进行其他更改，同时也防止删除了旧版本的 Git 而可能引发的问题（例如 Git 存储库和其他相关文件）。</p><p>最后在执行 <code>git --version</code>  就可以看到较新版本的 Git 了。</p><p><img src="/imgs/posts/%E5%9C%A8CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85Git%E5%B7%A5%E5%85%B7/image-20230509015818870.png" alt="image-20230509015818870"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Git 工具安装&lt;/h1&gt;
&lt;h2 id=&quot;方式一：通过包管理器安装&quot;&gt;方式一：通过包管理器安装&lt;/h2&gt;
&lt;p&gt;在 Linux 上安装 Git 只需要一行命令即可搞定，在 CentOS 系统中，执行如下命令即可安装：&lt;/p&gt;
&lt;figure class=&quot;highlig</summary>
      
    
    
    
    <category term="notes" scheme="https://yocy.top/categories/notes/"/>
    
    
    <category term="笔记" scheme="https://yocy.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="工具相关" scheme="https://yocy.top/tags/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Git" scheme="https://yocy.top/tags/Git/"/>
    
  </entry>
  
</feed>
